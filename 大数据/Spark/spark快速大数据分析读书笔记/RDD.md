### RDD

弹性分布式数据集：Resilient Distributed Datasets

> 为什么叫弹性
>
> 在任何时候都能进行重算是我们为什么把RDD描述为 `弹性` 的原因，当保存RDD数据的一台机器失败时候，Spark可以用这个特性重算丢掉的分区，该过程对用户透明。



Spark 中的 RDD 就是一个不可变的分布式对象集合。每个 RDD 都被分为多个分区，这些分区运行在集群中的不同节点上。

> 把RDD看成存放数据的集合是不对的，可以看成封装了计算逻辑的一种数据结构，相当于每个RDD是我们转化构建出来的，记录如何计算数据的执行列表。



用户可以使用两种方法创建 RDD：读取一个外部数据集，或在驱动器程序（driver端）里分发驱动器程序中的对象集合（比如 list 和 set）。



Spark RDD编程流程

1) 从外部数据源创建出RDD。
2) 使用诸如 filter 这样的算子对RDD进行转化为新的RDD
3) 判断是否需要将中间计算结果RDD 执行 `persist()` 或者 `cache()` 操作。
4) 使用行动操作（count，first） 触发一次计算。

#### 创建RDD

用户可以使用两种方法创建 RDD：读取一个外部数据集，或在驱动器程序里分发驱动器程序中的对象集合（比如 list 和 set）。

1. 读取外部数据集。

	读取外部文件

	```scala
	sc.textFile(file)
	```

2. 在`driver`端对一个集合进行并行化。

	```scala
	val lines = sc.parallelize(List("pandas", "i like pandas")
	```

	使用parallelize() 方法将一个集合转为RDD，可以快速创建一个RDD，缺点是需要把数据集先放进一台机器的内存中。



#### RDD 操作

RDD 支持两种类型的操作：转化操作（transformation） 和行动操作（action）

分成两类的标准：是否惰性计算。

> 根据Spark计算RDD的方式不同，所以分成这两类，本质上是看是否进行惰性计算。
>
> 如果对于一个特定的函数是属于转化操作还是行动操作感到困惑，你可以看看它的返回值类型：转化操作返回的是 RDD，而行动操作返回的是其他的数据类型



##### 1. 转化操作

- 转化操作，有一个RDD生成另一个RDD，例如根据谓词匹配筛选

	```scala
	var filterRDD = lines.filter(line => line.contains("Scala"))
	# 生成只包含Scala字符串的新的RDD
	```

- 转化操作会不会改变已有RDD的数据，该操作会生成一个新的RDD。

	```scala
	val inputRDD = sc.textFile("log.txt")
	val errorsRDD = inputRDD.filter(line => line.contains("error"))
	# filter 操作不会改变已有inputRDD的数据，该操作会返回一个全新的RDD
	```

   

​	通过转化操作，你从已有的 RDD 中派生出新的 RDD，Spark 会使用谱系图（lineage graph）来记录这些不同RDD 之间的依赖关系。Spark 需要用这些信息来按需计算每个 RDD，也可以依靠谱系图在持久化的 RDD 丢失部分数据时恢复所丢失的数据。

##### 2. 行动操作

- 行动操作 ，行动操作会对RDD进行计算，并把结果返回到Driver端
- 它们会把最终求得的结果返回到驱动器程序，或者写入外部存储系统中。会触发实际的计算。

- 由于操作需要生成实际的输出，所以他会强制执行那些求值必须用的RDD转换操作。需要注意的是，每当我们调用一个新的行动操作时，整个 RDD 都会从头开始计算。要避免这种低效的行为，用户可以将中间结果持久化。



- 默认情况下，Spark 的 RDD 会在你每次对它们进行行动操作时重新计算。如果想在多个行动操作中重用同一个 RDD ，可以使用 `RDD.persist()` 让 Spark 把这个 RDD 缓存下来。在第一次对持久化的RDD计算后，Spark会把RDD的内容保存在内存中（以分区的方式存储到各个节点上），这样在之后的行动操作中，就可以重用这些数据了。



#### 惰性求值

含义： 调用转换操作（map）不会触发执行，spark会记录操作的相关信息（血缘）。


Spark 使用惰性求值，可以合并一些操作，不同于MR程序需要组合计算逻辑，来减少MR个数。在Spark中，我们可以用连续简单的操作取代一个复杂的映射，性能不会损失多少，而且更容易管理和测试。

不要认为一个复杂的映射逻辑，可以比一连串的操作性能提升明显。

有些数据处理逻辑确实可以用一个超大SQL写，但是后期不好维护，而且也提升不了很大的性能。





