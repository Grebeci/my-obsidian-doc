MySQL 索引 在每本书中的内容都很多，其实都是推演索引的由来的前置部分花了大量的篇幅。如果熟悉查找相关的知识，会轻松不少。

所以，需要先学习查找相关的数据结构和算法的前置知识，主要包括两类数据结构（B+树和hash表）和查找相关的算法

- B+树的结构，由来。
- 顺序表（链表）查找和优化部分，以及如何推演到hash表。
- 查找的优化 ：排序和hash

学习MySQL索引主要包括

- 概念：聚簇/非聚簇，联合索引，索引的类型（普通/主键/单列/隐藏，。。。
- 操作：查看，创建，删除，隐藏
- InnoDB,MyISAM  具体查询引擎的实现
- 索引的代价
- 实践上的经验
	- 索引设计的原则
	- 哪些情况下适合建索引/哪些不适合建索引
- MySQL如何使用索引对查询优化
	- 对 where ,join  order by group by 的策略
	- 索引失效
	- 对字符串的策略



## 1. 概念

索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。

从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。 

按照 作用字段个数 进行划分，分成单列索引和联合索引。

#### 1.聚簇索引

是主键索引的InnoDB术语，InnoDB使用种B+树来实现索引，在B+树中，叶子节点存储按照主键排序的数据行，中间节点存储排序的索引（主键）。所以找到了索引就是找到了数据。

- 聚簇索引的排序和叶子节点存储数据，所以针对主键的 排序查找 和范围查找特别块。

- 因为聚簇索引排序特性，进行范围查询时候，，读取的数据块更少，IO更低。但是插入删除依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。
- 按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。

特点：

主键有序，数据和索引存放在一块，又称 `索引即数据，数据即索引`。

#### 2.非聚簇索引

又叫二级索引，叶子节点存放的是主键。定位到数据需要`回表`，也就是再查一下主键索引。

#### 3. 区分聚簇和非聚簇

找到了索引就找到了需要的数据，那么这个索引就是聚簇索引；索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询，这就是非聚簇索引。

#### 联合索引

使用多个列作为排序规则，也就是为多个列建立排序索引。比方让B+树按照 A1,A2 列大小排序，指的是先按照A1，排序，A1相同的按照A2排序。

注意联合二级索引不是分别建立索引，对每一列进行建立索引和建立联合索引排序规则是不同的。

## 2. 查询引擎的实现

对实现索引的数据结构的支持

| 存储引擎 | B+tree | full-text | hash索引 |
| -------- | ------ | --------- | -------- |
| InnoDB   | √      | √         | ×        |
| MyISAM   | √      | √         | ×        |
| Memory   | ×      | ×         | √        |
| NDB      | ×      | ×         | √        |
| Archive  | ×      | ×         | ×        |



#### InnoDB 的索引

默认B tree索引，但和MyISAM 实现是不同的。

按照主键顺序排序，维护一个B+树，叶子节点存储数据行，非叶子节点存储索引（主键）。特点是索引和数据存储在一起，找到了索引就找到了数据。对于InnoDB这种实现的主键索引，称之为 `聚簇索引`。



InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。

#### MyISAM 索引

默认B tree索引，叶子节点存储数据行的地址，非叶子存储索引，所以查找对应的数据还需要一次回表。相当于 "二级索引"。

MyISAM 将索引文件和数据文件分别存放，索引文件只保存数据的地址。

## 3. 操作

#### 3.1 创建索引

##### 1.建表指定

```mysql
CREATE TABLE table_name [col_name data_type]
[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC |
DESC]
```

- `UNIQUE`、`FULLTEXT`和`SPATIAL`为可选参数，分别表示唯一索引、全文索引和空间索引；
- `INDEX`与`KEY`为同义词，两者的作用相同，用来指定创建索引；
- `index_name`指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；
- `col_name`为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；
- `length`为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；
- `ASC`或`DESC`指定升序或者降序的索引值存储。

##### 2. 在已经存在的表上创建索引

**1.** **使用ALTER TABLE语句创建索引**

```mysql
ALTER TABLE table_name 
ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC]
```

**2.** **使用CREATE INDEX创建索引**

```mysql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name 
ON table_name (col_name[length],...) [ASC | DESC]
```

#### 3.2 删除索引

**1.** **使用ALTER TABLE删除索引**

```mysql
ALTER TABLE table_name DROP INDEX index_name;
```

**2.** **使用DROP INDEX语句删除索引**

```mysql
DROP INDEX index_name ON table_name;
```



#### 3.3 隐藏索引

从MySQL 8.x开始支持`隐藏索引（invisible indexes）`，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。`这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除`。

**1.** **创建表时直接创建** 

```mysql
CREATE TABLE tablename( 
    propname1 type1[CONSTRAINT1], 
    propname2 type2[CONSTRAINT2], 
    ……
    propnamen typen, 
    INDEX [indexname](propname1 [(length)]) INVISIBLE 
);
```

**2.** **在已经存在的表上创建**

```mysql
CREATE INDEX indexname 
ON tablename(propname[(length)]) INVISIBLE;
```

**3.** **通过ALTER TABLE语句创建**

```mysql
ALTER TABLE tablename 
ADD INDEX indexname (propname [(length)]) INVISIBLE;
```

**4.** **切换索引可见状态**

```mysql
ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 
ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引
```

## 4. 索引的设计原则

### 4.1 哪些情况适合索引

##### 1. 业务上/逻辑上 有唯一性的限制

>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba） 
>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。

##### 2.作为过滤条件的字段建索引

- 频繁作为查询条件的字段建索引
- update insert delete 的 where 条件列。如果更新的是非索引字段，效率提升更明显

##### 3.join 

- 连接字段建立索引，并且字段类型必须一致。

##### 4. group by order by , distinct 建索引

借助索引顺序的特性，分组，排序和去重均有性能提升

##### 5.优先使用简单类型建立索引

比如，数字类型，时间类型索引性能明显优于 字符串。

##### 6、区分度高（散列性）的适合做索引

##### 7. 使用最频繁的列放到联合索引的左侧 

这样也可以较少的建立一些索引。同时，由于"最左前缀原则"，可以增加联合索引的使用率。

##### 8.优先建立联合索引

在多个字段都要创建索引的情况下，联合索引优于单值索引

### 4.2 哪些情况不适合建索引

限制索引的数目，不要建立过多的索引。

##### 1. 数据量小的表不要使用索引

##### 2. 大量重复数据的列不要建立索引

##### 3. 经常更新的表（列）不要建过多的索引

##### 5. 不建议使用无序的值作为索引

例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等。

##### 6. 不要定义冗余或重复的索引

比如有和其他字段的联合索引，就不要建单列索引。



### 4.3 自增主键

由于InnoDB的聚簇索引的性质，插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。

但有时候业务上找不到有主键含义的列，但是InnoDB必须需要一个主键列，我们一般都会定义一个自增的ID列为主键。





### 字符串类型的建索引的原则

对于字符串



## 索引对查询的影响

##### 1. 全值匹配 

##### 2, 最左匹配原则

在查询中如果用到了联合索引，会按照联合索引的最左边是匹配，注意，当遇到范围查询(>、<、between、like)就会停止匹配。

比如联合索引 `(a,b,c)` 对于匹配条件含有 `(a)`,`(a,b)`,`(a.c)`,`(a,b,c)` 都有效。

##### 3. 主键插入顺序

为了避免页分裂的情况，主键使用auto_increment



### 2. 索引失效

##### 1. 如何看出索引失效



##### 2. 索引失效的原因

**计算，函数，类型转换(自动或者手动会导致索引失效)**

- 在索引列上使用函数会使索引失效,例如 `where substring(index_col, 1,3) = 'xxx'`

- 在索引的列进行计算,例如 where id + 1 = 10001

- 类型转换

	1. 当我们使用的字段是数值类型时，加引号或者不加引号（sql中单引号和双引号实现相同效果）都不影响索引的使用

		例如 id 是 int，这条SQL不会使索引失效 `SELECT * FROM 'test' WHERE id= '10000'; `  

	2. 当我们的字段是字符串类型时，不加引号的查询无法使用索引，加引号的查询才可正常使用索引。

		例如 id 是varchar 类型，这条SQL会使索引失效 `SELECT * FROM 'test' WHERE id = 10000;`，



不等于(`!=`,'<>')会使索引失效

is null 可以使用索引，is not null 无法使用索引



like 以通配符 `%` 开头会使索引失效

> Alibaba《Java开发手册》 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。



OR 前后存在非索引的列，索引失效



#### 对关联查询的优化

MySQL只支持 `Nested Loop Join` 这一种join algorithm。

如果被驱动表的连接键建了索引，就是 `Index Nested Loop Join`



##### 对于排序的优化

尽量使用 Index 完成 ORDER BY 排序，避免使用filesort 排序

##### 对于group by 优化

group by 先排序再分组，遵照索引建的最佳左前缀法则



##### 对字符串的索引策略



##### 前缀索引



