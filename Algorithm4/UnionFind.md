Q：并查集解决的问题（图的连通分量）。

Q：并查集的构造的数据结构（Quick-find 、Quick union）。

##### 问题建模：

```
  0   1                  2---3
     /                  / \ /
    4 —— 5             6   7

- Connected Components:
  - {0}
  - {1, 4, 5}
  - {2, 3, 6, 7}
```

##### Quick-find 方式

在Quick-find中，数组的每个索引对应一个对象，数组的值则指向该对象所属的连通分量的标识符。这种方法的优点是查找操作非常快，但是合并（union）操作可能较慢，因为需要更新数组中的多个条目。

**Data structure.**

- `id[]` : N 个元素

- p 和 q 如果 连通， 应该有同一个 id。

  `index` 表示节点，`p` (index)  = > `q` (id[index]) ， 表示 p 和 q 连通。如果 p 是独立的节点，则：`id == index[id]` （初始状态）。

  

##### Quick-union

在Quick-union中，每个对象指向另一个对象作为其父对象，从而形成一个树结构。查找操作包括追溯到树的根，而合并操作仅涉及将一个对象的根连接到另一个对象的根。Quick-union在合并操作上通常更高效，但查找操作可能需要更长的时间，特别是在树的深度很大时。

**Data structure.**

- `id[]` : N 个元素。
- id[i] is parent of i.
- Root of i is id[id[id[...id[i]...]]].

```shell
 0  1  9    6   7   8
      / \   |
     2   4  5
          |
          3
          
Index: 0 1 2 3 4 5 6 7 8 9
id[]:  0 1 9 4 9 6 6 7 8 9
```



优化： 使用路径压缩或加权等优化方法

